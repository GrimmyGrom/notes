# Структура документа

HTML-документ включает в себя *объявление типа документа* и **корневой элемент** `<html>`. Внутри элемента `<html>` находятся *заголовок документа* (`<head>`) и *тело документа* (`<body>`). Хотя содержимое `<head>` не видно для обычного пользователя, оно **крайне важно** для корректной работы сайта. В этой части размещается *вся метаинформация*: сведения для поисковиков и социальных сетей, иконки для вкладки браузера и ярлыка на мобильном экране, а также поведение и стиль отображения содержимого.

В этом разделе вы узнаете о компонентах, которые *не видны напрямую*, но **присутствуют почти на каждой веб-странице**.

Чтобы начать разработку сайта, важно сразу добавить компоненты, которые считаются *обязательными* для любой страницы:

* тип документа,
* язык содержимого,
* кодировка символов,
* название сайта или приложения.

## **Добавляйте в каждый HTML-документ**

Существуют элементы, которые должны входить *в каждую HTML-страницу*. Браузеры всё равно отобразят страницу, даже если эти элементы отсутствуют, но **они должны быть**. Всегда.

### `<!DOCTYPE html>`

Первым в любом HTML-документе идёт *преамбула*. В HTML это всего лишь строка `<!DOCTYPE html>`. На первый взгляд это похоже на HTML-элемент, но это не так. Это *особый узел*, называемый *doctype*. Он указывает браузеру, что нужно использовать **режим стандартов**. Если его не указать, браузер переключится в *режим совместимости* (quirks mode). Добавление doctype помогает избежать проблем, связанных с этим режимом.

### `<html>`

Элемент `<html>` — это **корневой элемент** HTML-документа. Он содержит в себе и `<head>`, и `<body>`, то есть всё, кроме самого doctype. Даже если вы не укажете его явно, браузер подставит его автоматически. Тем не менее, лучше всегда включать его вручную, потому что именно в этом элементе *указывается язык содержимого страницы*.

### Язык содержимого

Атрибут `lang`, добавляемый к тегу `<html>`, определяет **основной язык документа**. Его значение — это *двух- или трёхбуквенный код языка по стандарту ISO*, при необходимости дополненный кодом региона. Указание региона не обязательно, но **рекомендуется**, так как один и тот же язык может сильно различаться в зависимости от страны. Например, французский в Канаде (`fr-CA`) заметно отличается от французского в Буркина-Фасо (`fr-BF`). Это указание помогает *экранным читалкам, поисковым системам и переводчикам* корректно интерпретировать язык страницы.

Атрибут `lang` можно использовать не только в теге `<html>`. Если на странице встречается *текст на языке, отличном от основного*, к этому участку также стоит применить `lang`, чтобы явно указать на исключение. Как и в `<html>`, этот атрибут **не влияет на внешний вид** — он добавляет *семантику* и помогает вспомогательным технологиям и сервисам правильно распознать язык определённого фрагмента.

Кроме всего прочего, атрибут `lang` может использоваться и в CSS-селекторах. Например:

```html
<span lang="fr-fr">Ceci n'est pas une pipe.</span>
```

можно стилизовать с помощью селекторов:

```css
[lang|="fr"] { ... }
:lang(fr) { ... }
```

### `<head>`

Внутри открывающего и закрывающего тега `<html>` располагаются два основных дочерних элемента: **`<head>`** и **`<body>`**.

```html
<!DOCTYPE html>
<html lang="en-US">
  <head>
    ...
  </head>
  <body>
    ...
  </body>
</html>
```

Элемент `<head>`, или *заголовок метаданных документа*, содержит **всю служебную информацию** о сайте или приложении. В то время как `<body>` отвечает за **отображаемое содержимое**, `<head>` — это то, что *не видно пользователю напрямую*, но жизненно важно для работы страницы.

В этой части мы рассмотрим, какие компоненты обычно располагаются внутри открывающего и закрывающего тегов `<head></head>`.

#### Обязательные компоненты внутри `<head>`

Метаинформация документа — это:

* **кодировка символов (`<meta charset>`)**,
* **заголовок страницы (`<title>`)**,
* **настройки вьюпорта для мобильных устройств**,
* *описание страницы*,
* *базовый адрес (`<base>`) для относительных ссылок*,
* *ссылки на таблицы стилей (`<link rel="stylesheet">`)*,
* *иконки вкладки и ярлыков (`<link rel="icon">` и др.)*.

Вы можете не использовать всё из этого, но **атрибут кодировки, заголовок и настройки вьюпорта нужно указывать всегда**.

**Кодировка символов**

Первым элементом внутри `<head>` **должна быть декларация кодировки символов**. Она должна идти *до* заголовка `<title>`, чтобы браузер смог правильно отобразить текст не только в заголовке, но и во всём документе.

По умолчанию большинство браузеров используют кодировку `windows-1252`, зависящую от локали пользователя. Но **всегда следует указывать `UTF-8`**. Эта кодировка поддерживает все символы всех языков, включая редкие и экзотические знаки, и занимает от 1 до 4 байт на символ. Кроме того, она является **обязательной кодировкой в стандарте HTML5**.

Чтобы установить кодировку UTF-8, добавьте в `<head>` следующий элемент:

```html
<meta charset="utf-8" />
```

Объявляя кодировку `UTF-8` (регистр не имеет значения), вы даже можете использовать *эмодзи в заголовке страницы* (но **пожалуйста, не стоит этого делать**).

Указанная кодировка применяется **ко всему содержимому документа**, включая даже блоки `<style>` и `<script>`. Эта небольшая строка в `<head>` даёт возможность вставлять эмодзи *в имена CSS-классов* или использовать их в `querySelector` и других методах API выбора элементов (и снова — **не нужно так делать**).

Если вы всё же решите использовать эмодзи, делайте это **осознанно**: они должны *улучшать пользовательский опыт*, но **не ухудшать доступность**. Всегда помните о тех, кто пользуется экранными читалками или другими вспомогательными технологиями.

**Заголовок документа**

Главная страница и каждая внутренняя страница вашего сайта должны иметь **уникальный заголовок**. Содержимое между открывающим и закрывающим тегами `<title>` отображается в:

* вкладке браузера,
* списке открытых окон,
* истории просмотров,
* результатах поиска,
* карточках в социальных сетях (если не переопределено с помощью тегов `<meta>`).

Пример заголовка:

```html
<title>Machine Learning Workshop</title>
```

Хороший заголовок помогает пользователю сориентироваться и улучшает **SEO** и **доступность**, поэтому не стоит использовать дублирующие или слишком общие заголовки вроде `"Главная"` или `"Добро пожаловать"`.

**Метаданные вьюпорта**

Ещё один *обязательный* метатег — это тег `viewport`. Он отвечает за **адаптивность сайта**, позволяя содержимому корректно отображаться на экранах с разной шириной. Тег вьюпорта появился ещё в июне 2007 года — с выходом первого iPhone — но лишь недавно был официально задокументирован в спецификации.

Этот тег позволяет управлять *размером и масштабом окна просмотра* и предотвращает автоматическое сжатие контента — например, попытки уместить сайт шириной 960 пикселей на экран шириной 320 пикселей. Поэтому его **настоятельно рекомендуется использовать**.

Базовый вариант:

```html
<meta name="viewport" content="width=device-width" />
```

Этот код означает: *«Сделай сайт адаптивным, установив ширину контента равной ширине экрана»*. Помимо `width`, можно задать **масштаб** и **возможность масштабирования**, хотя по умолчанию эти параметры уже ориентированы на доступность. Если хотите указать всё явно, используйте:

```html
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=1" />
```

Viewport — это один из пунктов проверки доступности в отчёте **Lighthouse**. Ваш сайт успешно пройдёт аудит, если поддерживает масштабирование и не ограничивает максимальный размер экрана.

**Другие элементы в `<head>`**

В раздел `<head>` входит гораздо больше, чем может показаться. Фактически, именно туда помещаются все метаданные. Большинство элементов, которые вы встретите в `<head>`, рассмотрены здесь, но множество вариантов использования тега `<meta>` будет разобрано в следующей главе.

Вы уже видели мета-тег с указанием кодировки и заголовок документа, но есть и другие важные метаданные, которые не ограничиваются только тегами `<meta>`.

**CSS**

Именно в `<head>` подключаются стили для вашего HTML-документа. Если вы хотите глубже изучить стилизацию, существует отдельный курс по CSS, но вам всё равно нужно понимать, *как* подключать стили в HTML-документ.

Существует три способа подключения CSS: через тег `<link>`, тег `<style>` и атрибут `style`.

Два основных способа — это:

1. Подключение внешнего файла стилей с помощью тега `<link>` с атрибутом `rel="stylesheet"`.
2. Встраивание CSS напрямую в `<head>` с помощью парных тегов `<style>`.

Предпочтительным методом считается тег `<link>`. Подключение одного или нескольких внешних файлов стилей удобно как для разработчиков, так и для производительности сайта: вы управляете стилями в одном месте, а браузер может кэшировать внешний файл, чтобы не загружать его повторно при каждой навигации по сайту.

Синтаксис: `<link rel="stylesheet" href="styles.css">`, где `styles.css` — это URL вашего файла стилей. Иногда можно встретить атрибут `type="text/css"`. Необязательно! Если вы подключаете не CSS, то `type` нужен, но так как альтернативных типов нет, этот атрибут можно опустить. Атрибут `rel` указывает тип связи — в данном случае *stylesheet*. Если его не указать, CSS просто не подключится.

Если вы хотите, чтобы стили из внешнего файла подключались *внутри каскадного слоя*, но не имеете доступа к самому CSS-файлу, чтобы добавить туда информацию о слое, вы можете использовать директиву `@import` внутри тега `<style>`:

```html
<style>
  @import "styles.css" layer(firstLayer);
</style>
```

При использовании `@import` для подключения стилей в документ, в том числе в каскадные слои, директивы `@import` *обязательно* должны идти *первыми* в `<style>` или во внешнем файле стилей — перед любыми другими правилами, за исключением объявления кодировки символов.

Хотя каскадные слои всё ещё считаются относительно новой возможностью, и вы вряд ли часто встретите `@import` внутри `<style>` в `<head>`, *пользовательские свойства* (custom properties) в этом разделе — явление довольно распространённое:

```html
<style>
  :root {
    --theme-color: #226DAA;
  }
</style>
```

Стили, будь то через `<link>`, `<style>` или оба способа сразу, *должны размещаться в `<head>`*. Хотя они будут работать и в `<body>`, лучше помещать их в `<head>` — *для повышения производительности*. Это может показаться нелогичным: кажется, что нужно сначала загрузить контент, но на деле важно, чтобы браузер *сразу знал, как отрисовывать содержимое* при его загрузке. Предварительное подключение стилей предотвращает *ненужную перерисовку* элементов, которая возникает, если стиль применяется уже после первого рендеринга.

Есть, однако, один способ подключения стилей, который вы *никогда* не будете использовать в `<head>` документа — *встроенные стили (inline styles)*. Обычно вы не применяете встроенные стили в `<head>`, потому что таблицы стилей пользовательских агентов по умолчанию скрывают этот раздел. Однако, если, например, вы хотите сделать CSS-редактор *без использования JavaScript*, чтобы протестировать пользовательские элементы страницы, можно сделать `<head>` видимым через `display: block`, скрыть его содержимое, и с помощью `style`-атрибута *отобразить редактируемый блок* стилей:

```html
<style contenteditable style="display: block; font-family: monospace; white-space: pre;">
  head { display: block; }
  head * { display: none; }
  :root {
    --theme-color: #226DAA;
  }
</style>
```

Хотя вы можете добавлять встроенные стили непосредственно на тег `<style>`, куда веселее — *оформлять стили для тега `<style>` в ваших собственных стилях*. Ну, вы поняли.

**Другие применения тега `<link>`**

Тег `<link>` используется для *установления связей* между HTML-документом и внешними ресурсами. Некоторые из этих ресурсов загружаются, другие — просто предоставляют информацию. Тип связи определяется значением атрибута `rel`. На данный момент существует *25 допустимых значений* атрибута `rel`, которые можно использовать с тегами `<link>`, `<a>`, `<area>` или `<form>`, причём некоторые из них применимы ко всем этим тегам.

Обычно элементы `<link>`, относящиеся к метаинформации, размещаются в `<head>`, а те, что влияют на производительность, — в `<body>`.

Сейчас вы подключите три других типа ссылок в заголовке документа: `icon`, `alternate` и `canonical`. (Четвёртый тип — `rel="manifest"` — будет рассмотрен в следующем модуле).

**Фавикон**

Чтобы указать фавикон (иконку сайта), используйте тег `<link>` с атрибутом `rel="icon"`. Фавикон — это *маленькая иконка*, отображаемая на вкладке браузера, обычно слева от названия документа. Когда у пользователя открыто слишком много вкладок, их ширина уменьшается, и заголовок может исчезнуть вовсе — но иконка остаётся видимой. Чаще всего фавиконом служит логотип компании или приложения.

Если фавикон явно не указан, браузер будет искать файл с именем `favicon.ico` в корневом каталоге сайта. С помощью тега `<link>` вы можете использовать *любой другой файл и расположение*:

```html
<link rel="icon" sizes="16x16 32x32 48x48" type="image/png" href="/images/mlwicon.png" />
```

Эта запись говорит: «использовать файл `mlwicon.png` в ситуациях, когда нужны иконки 16, 32 или 48 пикселей». Атрибут `sizes` может принимать значение `any` для масштабируемых иконок или список размеров в формате `ширинаXвысота`, где значения — это 16, 32, 48 и так далее. Единицы пикселей опускаются, а `X` нечувствителен к регистру.

Также существуют *два нестандартных типа иконок для браузера Safari*:

```html
<link rel="apple-touch-icon" sizes="180x180" href="/images/mlwicon.png" />
<link rel="mask-icon" href="/images/mlwicon.svg" color="#226DAA" />
```

* `apple-touch-icon` — используется на *iOS-устройствах*, когда пользователь добавляет сайт на главный экран. Можно указать несколько иконок разных размеров под разные устройства.
* `mask-icon` — применяется, если пользователь *закрепляет вкладку* в Safari на macOS. Такая иконка должна быть *монохромной SVG*, а цвет заполняется через атрибут `color`.

Хотя технически возможно задавать разные фавиконы для каждой страницы или даже для каждой загрузки страницы — *не стоит так делать*. Для согласованности и удобства восприятия лучше использовать *одну и ту же иконку*. Например:

* У Twitter это синий птичка — увидев её на вкладке, вы сразу понимаете, что это Twitter.
* Google использует разные иконки для разных приложений (почта, календарь и т. д.), *но все они оформлены в одном цветовом стиле*.

Так пользователь легко узнаёт содержимое вкладки *просто по иконке*, не кликая на неё.

**Альтернативные версии сайта**

Атрибут `rel="alternate"` используется для указания *переводов* или *альтернативных представлений* сайта.

Предположим, у нас есть версии сайта на французском и бразильском португальском:

```html
<link rel="alternate" href="https://www.machinelearningworkshop.com/fr/" hreflang="fr-FR" />
<link rel="alternate" href="https://www.machinelearningworkshop.com/pt/" hreflang="pt-BR" />
```

При использовании `alternate` для перевода обязательно указывать атрибут `hreflang`.

Но значение `alternate` применяется не только для переведённых версий. Например, с помощью атрибута `type` можно определить альтернативный URI для RSS-ленты, если указать тип `application/rss+xml` или `application/atom+xml`. Вот как можно сослаться на условную PDF-версию сайта:

```html
<link rel="alternate" type="application/x-pdf" href="https://machinelearningworkshop.com/mlw.pdf" />
```

Если `rel` установлен как `alternate stylesheet`, то это определяет *альтернативный стиль оформления*, и в этом случае обязательно нужно указать атрибут `title`, задающий имя этой альтернативной темы.

**Канонический адрес**

Если вы создаёте несколько переводов или версий сайта *Machine Learning Workshop*, поисковые системы могут запутаться, *какая из версий является основной*. Для этого используется `rel="canonical"`, чтобы указать *предпочтительный URL* для сайта или приложения.

Канонический адрес следует указывать *на всех переведённых страницах*, а также на главной, чтобы указать, какой URL считается основным:

```html
<link rel="canonical" href="https://www.machinelearning.com" />
```

Ссылка `rel="canonical"` особенно часто используется при *перепубликации контента* на различных платформах (например, блогах или СМИ), чтобы сохранить авторство оригинального источника. Если сайт распространяет один и тот же контент на нескольких площадках, он должен включать каноническую ссылку на оригинал.

**Сценарии**

Тег `<script>` используется для подключения, собственно, *скриптов*. По умолчанию это JavaScript. Если вы подключаете другой язык сценариев, необходимо указать атрибут `type` с MIME-типом или `type="module"`, если это *модуль JavaScript*. Только JavaScript и его модули интерпретируются и выполняются браузером.

Теги `<script>` могут содержать *встроенный код* или использоваться для подключения *внешнего файла*. В курсе MLW внешний файл не используется, потому что, вопреки распространённому мнению, для работы сайта JavaScript не обязателен. И к тому же — это путь изучения *HTML*, а не JavaScript.

Позже вы подключите небольшую часть JavaScript — пасхалку:

```html
<script>
  document.getElementById('switch').addEventListener('click', function() {
    document.body.classList.toggle('black');
  });
</script>
```

Этот код добавляет обработчик события для элемента с `id="switch"`. Важно помнить: *в JavaScript не стоит обращаться к элементу до того, как он будет создан в DOM*. Так как такого элемента ещё нет, скрипт пока тоже не включаем. Когда мы добавим элемент-переключатель, скрипт разместим *внизу `<body>`*, а не в `<head>`. Почему?

1. Нам нужно, чтобы элементы *уже существовали*, когда скрипт их вызывает (мы не используем `DOMContentLoaded`).
2. И главное — JavaScript *блокирует рендеринг*: при загрузке скрипта браузер приостанавливает загрузку других ресурсов и не возобновляет её, пока скрипт не выполнится.

По этой причине JavaScript чаще всего размещают *в конце документа*, а не в `<head>`.

Существуют два атрибута, которые помогают *снизить блокирующий эффект* JavaScript при загрузке и выполнении: `defer` и `async`.

* С атрибутом **`defer`** загрузка скрипта *не блокирует рендеринг* HTML. Скрипт будет выполнен *только после того*, как документ полностью отрендерится.

* С атрибутом **`async`** рендеринг также *не блокируется во время загрузки* скрипта, но как только скрипт загрузится — *браузер приостанавливает рендеринг*, чтобы выполнить скрипт сразу же.

**`<script>` (Стандартный тег)**

* **Рендеринг приостанавливается**, как только браузер встречает тег `<script>`.
* Браузер **загружает JavaScript** сразу в этот момент.
* **Скрипт выполняется сразу же** после загрузки.
* Лишь затем браузер **возобновляет разбор и отрисовку HTML**.

📌 **Влияние**: Блокирует разбор HTML и *замедляет загрузку страницы*, что может снизить ощущение скорости для пользователя.

**`<script defer>`**

* Браузер **продолжает разбор и отрисовку HTML**, не дожидаясь загрузки скрипта.
* Скрипт **загружается в фоновом режиме** во время разбора HTML.
* После полной отрисовки HTML **скрипт выполняется**.

📌 **Влияние**: *Не блокирует рендеринг HTML*. Скрипт запускается, когда DOM уже готов. Отличный вариант для скриптов, работающих с содержимым страницы.

**`<script async>`**

* Браузер **немедленно начинает загрузку JavaScript**, продолжая разбирать HTML.
* Как только скрипт загружен, **рендеринг приостанавливается для выполнения скрипта**.
* После этого браузер продолжает рендеринг страницы.

📌 **Влияние**: *Не блокирует загрузку и разбор*, но *может прервать отрисовку*, если скрипт загрузится слишком быстро. Подходит для независимых скриптов, например, аналитики.

**Сводная таблица**

| Атрибут          | Блокирует разбор HTML | Время выполнения скрипта   | Лучшее применение                          |
| ---------------- | --------------------- | -------------------------- | ------------------------------------------ |
| `<script>`       | Да                    | Сразу при обнаружении      | Маленькие встроенные или критичные скрипты |
| `<script defer>` | Нет                   | После полного разбора HTML | Скрипты, зависящие от структуры DOM        |
| `<script async>` | Нет                   | Сразу после загрузки       | Независимые скрипты (например, аналитика)  |

**Элемент `<base>`**

Существует ещё один элемент, который можно использовать *только внутри `<head>`*. Он применяется нечасто — это элемент `<base>`, позволяющий задать *базовый URL* и *целевое окно* (target) по умолчанию для всех относительных ссылок.

* Атрибут `href` задаёт *базовый URL* для всех относительных ссылок.
* Атрибут `target`, допустимый также для ссылок и форм, указывает, *где должны открываться ссылки*.
  По умолчанию используется `_self` — ссылка откроется в том же окне или фрейме.
  Также доступны:

  * `_blank` — в новом окне или вкладке,
  * `_parent` — в родительском фрейме (или в том же окне, если фреймов нет),
  * `_top` — в том же окне, но *выйдя из всех фреймов* (если таковые имеются).

Большинство разработчиков предпочитают добавлять `target` *непосредственно к отдельным ссылкам* или формам, если нужно особое поведение, а не использовать `<base>`.

```html
<base target="_top" href="https://machinelearningworkshop.com" />
```

Если наш сайт будет встроен в iframe, например, на сайте вроде Yummly, то благодаря тегу `<base>` *все ссылки* внутри документа будут открываться *вне iframe*, занимая *всю вкладку браузера*.

Однако у элемента `<base>` есть и недостатки. Например, *якорные ссылки* (`<a href="#ref">`) преобразуются в полноценный абсолютный адрес, как будто вы написали:

```html
<a target="_top" href="https://machinelearningworkshop.com#ref">
```

Это приведёт к *HTTP-запросу* по адресу `base`, даже если вы просто хотели прокрутку по странице.

Ещё несколько важных моментов о `<base>`:

* В документе может быть *только один* такой элемент.
* Он должен быть *размещён до любых относительных ссылок*, включая подключения скриптов или стилей.

**HTML-комментарии**

Обратите внимание, что скрипт обёрнут в угловые скобки, дефисы и восклицательный знак — именно так *в HTML оформляются комментарии*. Мы оставим скрипт закомментированным до тех пор, пока не добавим соответствующий контент на страницу. Всё, что находится между `<!--` и `-->`, *не будет отображаться и не будет обрабатываться* браузером.

Комментарии HTML можно размещать *в любом месте страницы* — в `<head>` или `<body>`. Исключение составляют блоки `<script>` и `<style>`, где следует использовать комментарии, соответствующие JavaScript и CSS:

* В JavaScript: `// однострочный` или `/* многострочный */`
* В CSS: `/* комментарий */`

Вы уже познакомились с основами того, что размещается внутри `<head>`. Но поскольку вы хотите изучить тему *глубже*, в следующих разделах мы рассмотрим **мета-теги** и узнаем, *как управлять отображением вашего сайта при публикации ссылок в соцсетях*.
